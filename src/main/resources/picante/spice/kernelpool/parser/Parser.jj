options{  LOOKAHEAD=1;  SUPPORT_CLASS_VISIBILITY_PUBLIC=false;  STATIC=false;}PARSER_BEGIN(Parser)package picante.spice.kernelpool.parser;import java.util.List;import java.util.ArrayList; import picante.spice.kernelpool.BasicKernelPool;import picante.spice.kernelpool.parser.time.TimeParser;class Parser{   private final TimeParser timeParser = new TimeParser();   /**     * The parser action to be utilized by the current instance.    * There need only be a single one.    */   private final ParserAction action = new ParserAction();      private double processDate(Token t) throws picante.spice.kernelpool.parser.time.ParseException {      /*       * Strip the leading '@' off the token's image before sending       * it on to the parser.        */        return timeParser.parse(t.image.substring(1,t.image.length()));   }      private double processDouble(Token t) {      /*       *  The NAIF text kernel format supports FORTRAN style numeric       *  specifications.  This includes exponent characters that are       *  'D' or 'd', in addition to the usual C-style 'e' or 'E'.        *  Translate any occurrences of this unusual exponent        *  specification to 'e' so parseDouble() will function properly.       */      String s = t.image.replaceAll("d|D","e");             /*       *  See if this token is PI.       */      if ( s.equalsIgnoreCase("PI") | s.equalsIgnoreCase("+PI") ) {         return Math.PI;      }            if ( s.equalsIgnoreCase("-PI") ) {         return -Math.PI;      }            return Double.parseDouble(s);    }         private String processQuotedString(Token t) {      String result = t.image;      /*       *  Remove the leading and trailing "'", as they are not part       *  of the string content we wish to return.       */      result = result.substring(1,result.length()-1);            /*       *  Replace any occurrences of the doubled quote "''" with a        *  a single quote "'".       */      result = result.replaceAll( "''", "'" );            return result;    }      /**    * Private assistance class that captures the current parser's    * action as it is built up.    */   private static class ParserAction {      String keyword;      boolean append;      boolean isStringValued;      List<Double> doubles = new ArrayList<Double>();      List<String> strings = new ArrayList<String>();            void clearLists() {         doubles.clear();         strings.clear();      }          void execute(BasicKernelPool pool) {               if ( append ) {            if (isStringValued) {               pool.appendStrings(keyword, strings);            } else {               pool.appendDoubles(keyword, doubles);            }         } else {            if (isStringValued) {               pool.addStrings(keyword, strings);            } else {               pool.addDoubles(keyword, doubles);            }         }            }         }   }PARSER_END(Parser)/* * The default state for the parser is comment collection, which we skip * everything until we end up encountering the "\begindata" token on a  * line by itself. */SKIP: { < ~[] > }/* * Once "\begindata" is encountered, transition to the KEYWORD_STATE, as * we are now expecting keyword value content. */SKIP: { < (<WHITESPACE>)* "\\begindata" (<WHITESPACE>)* <EOL> > : KEYWORD_STATE        | < #WHITESPACE: [" ","\t"] >         | < #EOL: ("\n"|"\r"|"\r\n") >  }/* * In the keyword state we are searching for any valid keyword definition. * Unfortunately, due to the fact NAIF permits '+' characters in keywords, * we have to split this up into four tokens.  The KEYWORD_PLUS_EQUALS is * a simple way to pick up the tightly bound "+=" situation, while allowing * '+' elsewhere in the keyword.  Also, though their documentation indicates * '.' is not permitted in a keyword, their parser allows it. *  * Transition out of KEYWORD_STATE whenever the +=, = constructs are  * encountered and into the VALUE_STATE. */<KEYWORD_STATE> SKIP: { < " " | "\r" | "\n" | "\t" > }<KEYWORD_STATE> SKIP: { < (<WHITESPACE>)* "\\begintext"                           (<WHITESPACE>)* <EOL> > : DEFAULT }<KEYWORD_STATE> TOKEN: { < LONE_BEGINTEXT: (<WHITESPACE>)* "\\begintext"                           (<WHITESPACE>)* > }<KEYWORD_STATE> TOKEN: { < KEYWORD_PLUS_EQUALS:                              (<KEYWORD_CHAR>)+ ("+=") > : VALUE_STATE }<KEYWORD_STATE> TOKEN: { < KEYWORD: (<KEYWORD_CHAR>)+ >                        | < #KEYWORD_CHAR:                             ~[" ","=","(",")","\t","\n","\r"]> }<KEYWORD_STATE> TOKEN: { < EQUALS: ("=") > : VALUE_STATE }<KEYWORD_STATE> TOKEN: { < PLUS_EQUALS: ("+=") > : VALUE_STATE }/* * The value state handles a single value assignment, or a multiple value * assignment, so long as the values are present on a single line.  It also * transitions into the LIST_STATE the moment a '(' is encountered.  This * is a clear indication of the intent to switch to a line insensitive * parse mode. * * Unfortunately, because I couldn't figure out how to manage the quoted * strings, and their associated states, I just simply replicated the * expressions for the three types of value tokens between both the * VALUE_STATE and LIST_STATE. */<VALUE_STATE> SKIP: { < " " | "\t" | "," > }<VALUE_STATE> TOKEN: { < DATE: "@" (~[" ",",","\t","\r","\n"])* > }<VALUE_STATE> TOKEN: { < NUMBER: (["+","-"])? ( (                           (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?                             | "." (["0"-"9"])+ (<EXPONENT>)?                              | (["0"-"9"])+ <EXPONENT>                              | (["0"-"9"])+ (<EXPONENT>)? ) | "PI" | "Pi" | "pI" | "pi" ) >                      |                      < #EXPONENT: ["e","E","d","D"] (["+","-"])? (["0"-"9"])+ > } <VALUE_STATE>  MORE: { "'" : VALUE_STRING }<VALUE_STATE>  TOKEN: { < LEFT_PAREN : "(" > : LIST_STATE }<VALUE_STATE>  TOKEN: { < NEWLINE: "\n" | "\r" | "\r\n" > : KEYWORD_STATE }/* * This state is used to consume all of the characters in a quoted string. * When it encounters the closing quoted string it will return to the  * VALUE_STATE. */<VALUE_STRING> MORE: { < ( ~["'", "\n", "\r"] | "''" ) > }<VALUE_STRING> TOKEN: { < QUOTED_STRING: "'" > : VALUE_STATE } /* * The LIST_STATE is used to tokenize a multi-line value expression. * Here, newlines are skipped as white space. We only transition  * back into the KEYWORD_STATE when encountering a ')'. */<LIST_STATE> TOKEN: { < RIGHT_PAREN : ")" > : KEYWORD_STATE }<LIST_STATE> SKIP: { < " " | "\t" | "," | "\n" | "\r" > }<LIST_STATE> TOKEN: { < LIST_DATE: "@" (~[" ",",","\t","\r","\n"])* > }<LIST_STATE> TOKEN: { < LIST_NUMBER: (["+","-"])? ( (                           (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?                             | "." (["0"-"9"])+ (<EXPONENT>)?                              | (["0"-"9"])+ <EXPONENT>                              | (["0"-"9"])+ (<EXPONENT>)? ) | "PI" | "Pi" | "pI" | "pi" ) > } <LIST_STATE>  MORE: { "'" : LIST_STRING }<LIST_STRING> MORE: { < ( ~["'", "\n", "\r"] | "''" ) > }<LIST_STRING> TOKEN: { < LIST_QUOTED_STRING: "'" > : LIST_STATE }   /** * Parse the contents of the configured stream into a newly created * basic kernel pool. */BasicKernelPool parse() :{ BasicKernelPool pool = new BasicKernelPool();  }{  try {   ( keyword(action)      { action.clearLists(); }   (values(action) | listValues(action))      { action.execute(pool); }   )* (<LONE_BEGINTEXT>)? <EOF>    { return pool; }   } catch ( NumberFormatException e ) {      throw new ParseException("Unable to parse double: " + e.getMessage());   } catch ( picante.spice.kernelpool.parser.time.ParseException e ) {      throw new ParseException("Unable to parse date: " + e.getMessage() );   }}/** * Parse keyword content into the supplied action. */private void keyword(ParserAction buffer) :{ Token t; }{ ( t=<KEYWORD_PLUS_EQUALS>     {  buffer.keyword = t.image.substring(0,t.image.length()-2);        buffer.append=true; }   | t=<KEYWORD> (  <EQUALS>      { buffer.append=false; }                  | <PLUS_EQUALS> { buffer.append=true;  } )    { buffer.keyword=t.image; } ) }private void values(ParserAction buffer) throws picante.spice.kernelpool.parser.time.ParseException :{ Token t; }{  ( ( t=<QUOTED_STRING>        { buffer.strings.add(processQuotedString(t)); } )+           { buffer.isStringValued=true; }    | ( ( t=<DATE>          { buffer.doubles.add(processDate(t)); } )     | ( t=<NUMBER>          { buffer.doubles.add(processDouble(t)); } ) )+       { buffer.isStringValued=false; } )      (<NEWLINE>)* }private void listValues(ParserAction buffer) throws picante.spice.kernelpool.parser.time.ParseException :{  Token t; }{  <LEFT_PAREN>    ( ( t=<LIST_QUOTED_STRING>        { buffer.strings.add(processQuotedString(t)); } )+          { buffer.isStringValued=true; }    | ( ( t=<LIST_DATE>           { buffer.doubles.add(processDate(t)); } )     | ( t=<LIST_NUMBER>           { buffer.doubles.add(processDouble(t)); } ) )+       { buffer.isStringValued=false; }  )   <RIGHT_PAREN> }  