package picante.mechanics;

import java.util.List;
import java.util.Set;

/**
 * An interface describing a source of derived ephemeris position and state functions.
 * 
 * <p>
 * <b>Implementor Notes:</b> Choices available: ignore coverage argument supplied to create
 * functions. Level of thread safety (none, accessing create methods, accessing transform methods.)
 * Whether the internal frame provider is always to be that of a particular implementation that
 * functions well with your implementation. Does your implementation do any checking at construction
 * time to verify that the links can be met over the requested times?
 */
public interface EphemerisProvider {

  /**
   * Retrieves the list of ephemeris sources in load order from the provider.
   * 
   * @param buffer a list to which the sources of the ephemeris provider are to be appended. The
   *        first entry added to the list is the lowest priority, the last the highest.
   * 
   * @return a reference to buffer for convenience
   */
  public List<PositionVectorFunction> getEphemerisSourcesInLoadOrder();

  /**
   * Adds the list of ephemeris ID codes currently known by the provider to the supplied set. This
   * includes both ID codes that have defining functions in the provider, and those that do
   * not--which are, in a sense, root nodes of the tree structure
   * 
   * @param buffer the buffer to receive the additional ephemeris ID codes
   * 
   * @return a reference to buffer for convenience.
   */
  public Set<EphemerisID> getKnownObjects(Set<EphemerisID> buffer);

  /**
   * Answers the question, does this provider know about a particular ID? This could be answered by
   * asking the provider for its set of known frames, but this convenience method can be implemented
   * more efficiently.
   * <p>
   * <b>Note</b>All this implies is that a frame source contains some data connecting to this
   * particular frame. It may not be possible to connect two arbitrary frames at any time of which
   * the provider is aware.
   * </p>
   * 
   * @param id the ephemeris ID of interest.
   * 
   * @return true if there exists a source with data for <code>id</code> loaded into the instance of
   *         the provider
   */
  public boolean isAwareOf(EphemerisID id);

  /**
   * Retrieves an unmodifiable copy of the frame provider supporting the frame transformations
   * required to create the various ephemeris functions generated by the instance.
   * 
   * @return a reference to the internal frame provider
   */
  public FrameProvider getFrameProvider();

  /**
   * Create a derived state vector function that links a supplied target to a supplied observer in
   * the desired frame over the supplied time domain.
   * 
   * @param target the ephemeris ID of the object to which the position vectors point.
   * @param observer the ephemeris ID of the object from which the position vectors emanate.
   * @param frame the frame ID of the frame in which the observer to target position vector and its
   *        time derivative are to be expressed
   * @param domain the time domain over which the position vectors are expected to be computed.
   *        Note: Implementors may ignore this argument entirely, so as such consider it a
   *        suggestion at best. If you are working with a strict, construction time checking
   *        implementation, you must supply a subset of the available coverage loaded into the
   *        provider or obtain a resultant exception
   * 
   * @return a newly created, derived implementation of a state vector function connecting the
   *         <code>observer</code> to the <code>target</code> in the requested <code>frame</code>
   *         over times specified by <code>domain</code>.
   * 
   */
  public StateVectorFunction createStateVectorFunction(EphemerisID target, EphemerisID observer,
      FrameID frame, Coverage domain);


  /**
   * Create a derived position vector function that links a supplied target to a supplied observer
   * in the desired frame over the supplied time domain.
   * 
   * @param target the ephemeris ID of the object to which the position vector function vectors
   *        point.
   * @param observer the ephemeris ID of the object from which the position vector function vectors
   *        emanate.
   * @param frame the frame ID of the frame in which the observer to target position vector is to be
   *        expressed
   * @param domain the time domain over which the position vectors are expected to be computed.
   *        Note: Implementors may ignore this argument entirely, so as such consider it a
   *        suggestion at best. If you are working with a strict, construction time checking
   *        implementation, you must supply a subset of the available coverage loaded into the
   *        provider or obtain a resultant exception
   * 
   * @return a newly created, derived implementation of a position vector function connecting the
   *         <code>observer</code> to the <code>target</code> in the requested <code>frame</code>
   *         over times specified by <code>domain</code>.
   * 
   */
  public PositionVectorFunction createPositionVectorFunction(EphemerisID target,
      EphemerisID observer, FrameID frame, Coverage domain);


}
