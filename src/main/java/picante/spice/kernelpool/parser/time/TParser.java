/* TParser.java */
/* Generated By:JavaCC: Do not edit this line. TParser.java */
package picante.spice.kernelpool.parser.time;

import java.io.Reader;
import java.io.StringReader;

/**
* This parser is an attempt to mimic the NAIF/SPICELIB routine TPARSE
* for general time string parsing.
*/
class TParser implements TParserConstants {

   /**
    *  This number was taken from the SPICELIB routine J2000,
    *  and is the number of days between the Julian date 0.0
    *  and the reference epoch, Jan 01 2000 12:00.
    */
   private static final double J2000 = 2451545.0;

   /**
    *  This number was taken from the SPICELIB routine SPD.
    */
   private static final double SECONDS_PER_DAY = 86400.0;

   /**
    *  This number is used to define the default base century
    *  in which two digit years are to start.
    */
   private static final int DEFAULT_CENTURY = 1900;

   /**
    *  The two digit years begin at this lower bound.  That is
    *  if a year is specified '69-JAN-01 it is processed to
    *  1969-JAN-01.  Thus, anything between [0,68] is converted
    *  to [2000,2068].
    */
   private static final int CENTURY_LOWER_BOUND = 1969;

   /**
    *  Parse a time string into seconds past the J2000 reference epoch on 
    *  a formal calendar (86400 seconds per day).
    *
    *  @param  timeString  a string, containing a formal time specification.
    *
    *  @return the number of seconds, past the J2000 reference epoch, on a
    *          formal calendar (86400 seconds per day).  Note: the J2000 
    *          reference epoch is: January 1, 2000 12:00:00.000.
    */
   public double parse ( String timeString ) throws ParseException {
      initialize(new StringReader(timeString));

      /*
       *  Now that the parser is initialized (and thus the token manager)
       *  reset the special token lists, from any of our last parsing 
       *  attempts.  Although it seemed feasible to do this in the parseTime
       *  production, just prior to the return statement, this would not
       *  be reset if any ParseExceptions were thrown in the process of
       *  analyzing the string.  Here, we're assured it will be clean 
       *  prior to invoking the parser.
       */
      token_source.resetSpecialTokenLists();

      try {

         return parseTime();

      } catch ( ParseException pe ) {

         /*
          *  The first pass failed, try replacing dashes and single
          *  slashes with whitespace.  Note: this is a slightly 
          *  complicated process, as we have to preserve the double
          *  slash day of year delimiter.
          */
          String newTime = timeString.replaceAll("-", " ");
          newTime = newTime.replaceAll("//", "-");
          newTime = newTime.replaceAll("/", " ");
          newTime = newTime.replaceAll("-", "//");

         /*
          *  Initialize the parser with the newTime string, and try
          *  again.
          */
         initialize(new StringReader(newTime));
         token_source.resetSpecialTokenLists();

         try {
                return parseTime();
         } catch ( ParseException secondpe ) {
                throw new ParseException ( "Both primary and secondary parsing " +
                   "passes have failed.  Primary exception was: " + pe.getMessage() +
                   " Secondary exception was: " + secondpe.getMessage() );
         }
      }
   }

   /**
    *  This private method is used to initialize and reinitialize the 
    *  static parser object.  It provides a consolidated access point
    *  for the maintenance of the single instance of the parser.
    */
   private void initialize( Reader r ) {
      ReInit( r );
   }

   /**
    *  Convert a Julian date specification of time on a formal calendar
    *  to seconds past the J2000 reference epoch.
    *
    *  @param d  the Julian date to convert to seconds past J2000.
    *
    *  @return  the number of seconds ellapsed from J2000 on a formal
    *           calendar.
    */
   private static double julianDateToSecondsPastJ2000( double d ) {
      return ( d - J2000 ) * SECONDS_PER_DAY;
   }

   /**
    *  Convert a year less than 100 to a year between 1969 and 2068.  If
    *  the era "AD" is specified return the year untouched.
    *
    *  This conversion is the default one employed by SPICE, though it
    *  is configurable.  Note: input years supplied to this routine 
    *  that lie outside the range [0,99] are simply returned untouched.
    *  This permits the routine to be used thusly:
    *  <pre>
    *     year = processTwoDigitYears(year);
    *  </pre>
    *  without regard for whether year is less than 100 or not.
    */
   private int processTwoDigitYears ( int year ) {

      if ( token_source.era.size() == 1 && token_source.era.get(0).equals("AD") ) {
         return year;
      }

      if ( token_source.era.size() == 1 && token_source.era.get(0).equals("BC") && year == 0 ) {
         // special case for 1 B.C.
         return year;
      }

      if ( ( year >= 100 ) || ( year < 0 ) ) {
         return year;
      }
      year = year + DEFAULT_CENTURY;

      if ( year < CENTURY_LOWER_BOUND ) {
         year += 100;
      }

      return year;
   }

    /**
     *  Apply the Muller-Wimberly formula to convert a year and day of
     *  year to number of seconds past the J2000 reference epoch on a 
     *  formal calendar (86400 seconds per day).
     *
     *  @param year  an integer containing the fully qualified year to
     *               convert.
     *  @param dayOfYear  an integer containing the number of days in the
     *                    specified year.
     *
     *  @return  the number of seconds past the J2000 reference epoch on
     *           a formal calendar (86400 seconds per day).
     */
    private static double mullerWimberly( int year, int dayOfYear ) {

       /*
        *  Due to the way the Muller-Wimberly formula is implemented
        *  in the year, month, day routine, we can simply evaluate 
        *  the function at month 1, day dayOfYear and obtain the 
        *  correct result.
        */
       return mullerWimberly(year, 1, dayOfYear);
    }

    /**
     *  Apply the Muller-Wimberly formula to convert year, month, and day
     *  to number of seconds past the J2000 reference epoch on a formal 
     *  calendar (86400 seconds per day).
     *
     *  Unusual inputs may be supplied to this routine, and it will process
     *  the loose interpretations of day and month correctly.  That is to say
     *  as long as day and month are positive integers, this routine will
     *  convert the time accordingly.  The 13th month of year 1900, would be
     *  equivalent to the 1st month of year 1901, etc.
     *
     *  @param year  an integer containing the fully qualified year to
     *               convert.
     *  @param month  an integer containing the month of year to convert.
     *  @param day  an integer containing the day of month to convert.
     *
     *  @return  the number of seconds past the J2000 reference epoch on
     *           a formal calendar (86400 seconds per day).
     */
    private static double mullerWimberly ( int year, int month, int day ) {

       boolean adjust=false;
       int temp;
       int q=0;

       /*
        *  The Muller-Wimberly formula does not work for years
        *  less than 0.  So we boost the year by an appropriate
        *  multiple of 400, and then subtract the appropriate 
        *  number of days later.
        */
       if ( year < 1 ) {
          adjust=true;
          temp=year;

          /*
           *  Compute the integer quotient and non-negative remainder
           *  of temp and 400.
           */
          q = temp/400;
          year = temp - 400*q;

          if ( year < 0 ) {
             q = q-1;
             year = year + 400;
          }

          year = year + 400;
          q = q-1;
       }

       /*
        *  Now apply the Muller-Wimberly formula.
        */
       day = 367*year - 7*(year+(month+9)/12)/4
                      - 3*((year+(month-9)/7)/100+1)/4
                      + 275*month/9 + day - 730516;

       /*
        *  Adjust day by the appropriate multiple of 400 years, 
        *  if necessary.
        */
       if ( adjust ) {
          day = day + q*(400*365 + 97);
       }

       /*
        *  Return the number of seconds corresponding to day.
        *  Note: we have to subtract 0.5 from day, because our
        *  J2000 reference epoch starts at noon, not midnight.
        */
       return ((double) day - 0.5)*SECONDS_PER_DAY;
    }

    /**
     *  Correct a year for an era specification, if present in the
     *  TokenManager's era list.
     *
     *  @param year  The year specification to correct.
     *
     *  @return  the year corrected for any era specification, 
     *           namely (1-year) if the era "B.C." is specified.
     *           Otherwise it simply returns the input year.
     *
     *  @throws  ParseException if the TokenManager has recorded 
     *           more than one era specification, or if the recorded
     *           specification is unknown.
     */
    private int correctYearForEra(int year) throws ParseException {

       if ( token_source.era.size() == 0 ) {
          return year;
       }
       else if ( token_source.era.size() > 1 ) {
          throw new ParseException ( "Multiple era specifications supplied." );
       }

       if ( token_source.era.get(0).equals("AD") ) {
          return year;
       }
       else if ( token_source.era.get(0).equals("BC") ) {
          return 1 - year;
       }
       else {
          throw new ParseException ( "Unrecognized era specification: [" +
             token_source.era.get(0) + "] supplied." );
       }
    }

    private String correctHourForAMPM(String hourString) throws ParseException {
        if ( token_source.ampm.size() == 0) {
            return hourString;
        } else if ( token_source.ampm.size() > 1 ){
            throw new ParseException ( "Multiple AM/PM specifications supplied." );
        }

        double hour = Double.parseDouble(hourString);
        if (hour < 1 || hour >= 13) {
            throw new ParseException ( "Hours must be between 1 and 12 inclusive when A.M. or P.M. is specified." );
        }

        if (hour >= 12) hour -= 12;
        if ( token_source.ampm.get(0).equals("AM") ) {
            return Double.toString(hour);
        }
        else if ( token_source.ampm.get(0).equals("PM") ) {
            return Double.toString(hour + 12);
        }  else {
              throw new ParseException ( "Unrecognized AM/PM specification: [" +
                 token_source.era.get(0) + "] supplied." );
        }
    }

    /**
     *  Check to see if more than one weekday was specified.
     *  
     *  @throws  ParseException if more than one weekday appears in the
     *           token manager's weekday list.
     */
    private void checkWeekday() throws ParseException {

       if ( token_source.weekday.size() > 1 ) {
          throw new ParseException ( "Multiple weekdays specified.  This " +
              "is explicitly forbidden by the parser." );
       }
    }

    /**
     *  Simple class to capture multiple values returned when parsing
     *  year and day of year from the same non-terminal.
     */
    static class YearDayOfYear {
       int year;
       int dayOfYear;
    }

    /**
     *  Simple class to capture multiple values returned when parsing
     *  year, month, day from the same non-terminal.
     */
    static class YearMonthDay {
       int year;
       int month;
       int day;
    }

/*
 *  Top-level non-terminal that handles all of the time-strings managed
 *  by this parser.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double parseTime() throws ParseException {double d;
    if (jj_2_1(2147483647)) {
      d = julianDate();
    } else if (jj_2_2(2147483647)) {
      d = isoTime();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUMBER:
      case QUOTED_YEAR:
      case YEAR:
      case UNSIGNED_INTEGER:
      case JAN:
      case FEB:
      case MAR:
      case APR:
      case MAY:
      case JUN:
      case JUL:
      case AUG:
      case SEP:
      case OCT:
      case NOV:
      case DEC:
      case YEARAD:
      case YEARBC:{
        d = calendarTime();
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
/*
   	   *  Check if multiple weekdays were captured by the token manager.
   	   *  This method simply throws a ParseException if something is wrong.
   	   */
           checkWeekday();

      {if ("" != null) return d;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse a Julian Date formatted time string.
 * 
 *  This non-terminal attempts to parse Julian Date time strings in 
 *  the SPICE kernel pool, tparse format.  The token <JD> must appear
 *  in the stream, either before or after a floating point number.
 *  Negative floating point numbers have to be handled in a special
 *  way, by the parser, rather than the token manager due to the 
 *  fact that dashes are reserved characters in other time formats
 *  supported by this parser.
 *
 *  The basic acceptable formats for this production are:
 *     -123124.123JD  or JD-1231241.123
 *
 *  The floating point component may be omitted and it will still 
 *  parse properly.
 *
 *  @return  seconds past the J2000 reference epoch on a formal 
 *           86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double julianDate() throws ParseException {Token t;
   double d;
   boolean negate=false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case JD:{
      jj_consume_token(JD);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DASH:{
        jj_consume_token(DASH);
negate = true;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER:{
        t = jj_consume_token(UNSIGNED_INTEGER);
        break;
        }
      case YEAR:{
        t = jj_consume_token(YEAR);
        break;
        }
      case NUMBER:{
        t = jj_consume_token(NUMBER);
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
d=Double.parseDouble(t.image);
      break;
      }
    case NUMBER:
    case YEAR:
    case UNSIGNED_INTEGER:
    case DASH:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DASH:{
        jj_consume_token(DASH);
negate = true;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNSIGNED_INTEGER:{
        t = jj_consume_token(UNSIGNED_INTEGER);
        break;
        }
      case YEAR:{
        t = jj_consume_token(YEAR);
        break;
        }
      case NUMBER:{
        t = jj_consume_token(NUMBER);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
d=Double.parseDouble(t.image);
      jj_consume_token(JD);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
if ( token_source.weekday.size() != 0 ) {
             {if (true) throw new ParseException ( "Found weekday specification: [" +
                token_source.weekday.get(0) + "].  Weekday specifications " +
                "are not permitted in Julian Date time strings." );}
          }

      if ( token_source.era.size() != 0 ) {
         {if (true) throw new ParseException ( "Found era specification: [" +
            token_source.era.get(0) + "].  Era specifications are " +
            "not permitted in Julian Date time strings." );}
      }

      if ( negate ) {
         d = -d;
      }
      {if ("" != null) return julianDateToSecondsPastJ2000(d);}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse an ISO formatted time string.
 *
 *  This non-terminal attempts to parse ISO specification formatted
 *  time strings in the SPICE kernel pool, tparse format.  The token
 *  <ISOT> must appear in the stream, and further must separate the
 *  year and day of year specification (or month/day) from the supplied
 *  hours, minutes and seconds, if any.
 *
 *  Due to the nature of this format, fairly strict adherence to it is
 *  required.  SPICE does allow a semi-lax interpretation of each of the 
 *  fields in the time string.  That is months, days, day of year, hours,
 *  minutes, and seconds may be specified in excess of their strict 
 *  ranges, but each must be less than four digits to the left of the
 *  decimal point.
 *
 *  The range of formats handled by this non-terminal are:
 *  <pre>
 *             Y-i-iT ........ YmD
 *             Y-i-iTi ....... YmDH
 *             Y-i-iTi:i ..... YmDHM
 *             Y-i-iTi:i:i ... YmDHMS
 *             Y-i-iTi:i:n ... YmDHMS
 *             Y-i-iTi:n ..... YmDHM
 *             Y-i-iTn ....... YmDH
 *             Y-iT .......... Yy
 *             Y-iTi ......... YyH
 *             Y-iTi:i ....... YyHM
 *             Y-iTi:i:i ..... YyHMS
 *             Y-iTi:i:n ..... YyHMS
 *             Y-iTi:n ....... YyHM
 *             Y-iTn ......... YyH
 *             i-i-iT ........ YmD
 *             i-i-iTi ....... YmDH
 *             i-i-iTi:i ..... YmDHM
 *             i-i-iTi:i:i ... YmDHMS
 *             i-i-iTi:i:n ... YmDHMS
 *             i-i-iTi:n ..... YmDHM
 *             i-i-iTn ....... YmDH
 *             i-iT .......... Yy
 *             i-iTi ......... YyH
 *             i-iTi:i ....... YyHM
 *             i-iTi:i:i ..... YyHMS
 *             i-iTi:i:n ..... YyHMS
 *             i-iTi:n ....... YyHM
 *             i-iTn ......... YyH
 *   </pre>
 *   where:
 *   <pre>
 *             i  ---  unsigned integer
 *             n  ---  unsigned float
 *             Y  ---  Year
 *             m  ---  Month
 *             D  ---  Day of Month
 *             y  ---  Day of Year
 *             H  ---  Hour
 *             M  ---  Minute
 *             S  ---  Second
 *   </pre>
 *
 *   Note: two digit years, the leading i specified above, are interpretted 
 *   by the parser as occurring between 1969 and 2068.
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double isoTime() throws ParseException {YearDayOfYear yd;
   YearMonthDay ymd;
   double d=0;
   double e;
    if (jj_2_3(2147483647)) {
      ymd = isoYearMonthDay();
d=mullerWimberly(ymd.year, ymd.month, ymd.day);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case YEAR:
      case UNSIGNED_INTEGER:{
        yd = isoYearDay();
d=mullerWimberly(yd.year, yd.dayOfYear);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
d+=e;
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    jj_consume_token(0);
if ( token_source.weekday.size() != 0 ) {
         {if (true) throw new ParseException( "Found weekday specification: [" +
            token_source.weekday.get(0) + "].  Weekday specifications " +
            "are not permitted in ISO time strings." );}
      }

      if ( token_source.era.size() != 0 ) {
         {if (true) throw new ParseException( "Found era specification: [" +
            token_source.era.get(0) + "].  Era specifications are " +
            "not permitted in ISO time strings." );}
      }

      {if ("" != null) return d;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse the year, month, and day leading part of an ISO time specification.
 *
 *  @return  a YearMonthDay containing the year, month, and day parsed out
 *           of the leading tokens in the ISO time string.  Note: the year
 *           field of the YearMonthDay object is, if 2 digits, properly 
 *           converted to the [1969,2068] range.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public YearMonthDay isoYearMonthDay() throws ParseException {YearMonthDay ymd = new YearMonthDay();
        Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
      break;
      }
    case YEAR:{
      t = jj_consume_token(YEAR);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
ymd.year = processTwoDigitYears(Integer.parseInt(t.image));
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
ymd.month = Integer.parseInt(t.image);
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
ymd.day = Integer.parseInt(t.image);
    jj_consume_token(ISOT);
{if ("" != null) return ymd;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse the year and day of year leading part of an ISO time specification.
 *
 *  @return  a YearDayOfYear containing the year and day of year parsed out
 *           of the leading tokens in the ISO time string.  Note: the year
 *           field of the YearDayOfYear object is, if 2 digits, properly 
 *           converted to the [1969,2068] range.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public YearDayOfYear isoYearDay() throws ParseException {YearDayOfYear yd = new YearDayOfYear();
   Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
      break;
      }
    case YEAR:{
      t = jj_consume_token(YEAR);
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
yd.year = processTwoDigitYears(Integer.parseInt(t.image));
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
yd.dayOfYear = Integer.parseInt(t.image);
    jj_consume_token(ISOT);
{if ("" != null) return yd;}
    throw new Error("Missing return statement in function");
}

/*
 *  Describe time formats supported by calendarTime in detail.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double calendarTime() throws ParseException {double d;
    if (jj_2_4(2147483647)) {
      d = strictYearDayOfYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_5(2147483647)) {
      d = integerMinusDayOfYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_6(2147483647)) {
      d = integerDayOfYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_7(2147483647)) {
      d = dayOfYearStrictYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_8(2147483647)) {
      d = spaceDelimitedStrictYearMonthDay();
{if ("" != null) return d;}
    } else if (jj_2_9(2147483647)) {
      d = spaceDelimitedStrictYearDayOfYear();
{if ("" != null) return d;}
    } else if (jj_2_10(2147483647)) {
      d = dashedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_11(2147483647)) {
      d = slashedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_12(2147483647)) {
      d = slashedMonthDayInteger();
{if ("" != null) return d;}
    } else if (jj_2_13(2147483647)) {
      d = trailingDashedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_14(2147483647)) {
      d = trailingSlashedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_15(2147483647)) {
      d = trailingSlashedMonthDayInteger();
{if ("" != null) return d;}
    } else if (jj_2_16(2147483647)) {
      d = spaceDelimitedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_17(2147483647)) {
      d = spaceDelimitedStrictYearDayNamedMonth();
{if ("" != null) return d;}
    } else if (jj_2_18(2147483647)) {
      d = spaceDelimitedStrictYearNamedMonthDay();
{if ("" != null) return d;}
    } else if (jj_2_19(2147483647)) {
      d = spaceDelimitedIntegerDayNamedMonth();
{if ("" != null) return d;}
    } else if (jj_2_20(2147483647)) {
      d = spaceDelimitedDayNamedMonthStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_21(2147483647)) {
      d = spaceDelimitedIntegerNamedMonthDay();
{if ("" != null) return d;}
    } else if (jj_2_22(2147483647)) {
      d = spaceDelimitedNamedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_23(2147483647)) {
      d = spaceDelimitedNamedMonthDayInteger();
{if ("" != null) return d;}
    } else if (jj_2_24(2147483647)) {
      d = dayNamedMonthSplitStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_25(2147483647)) {
      d = namedMonthDaySplitStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_26(2147483647)) {
      d = trailingDayNamedMonthStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_27(2147483647)) {
      d = trailingNamedMonthDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_28(2147483647)) {
      d = trailingStrictYearNamedMonthDay();
{if ("" != null) return d;}
    } else if (jj_2_29(2147483647)) {
      d = trailingStrictYearDayNamedMonth();
{if ("" != null) return d;}
    } else if (jj_2_30(2147483647)) {
      d = trailingStrictYearMinusDayOfYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_31(2147483647)) {
      d = trailingDayOfYearMinusStrictYearDelimiter();
{if ("" != null) return d;}
    } else if (jj_2_32(2147483647)) {
      d = leadingStrictYearTrailingDayNamedMonth();
{if ("" != null) return d;}
    } else if (jj_2_33(2147483647)) {
      d = yearNamedMonthDecimalDay();
{if ("" != null) return d;}
    } else if (jj_2_34(2147483647)) {
      d = yearDecimalDayNamedMonth();
{if ("" != null) return d;}
    } else if (jj_2_35(2147483647)) {
      d = namedMonthDecimalDayYear();
{if ("" != null) return d;}
    } else if (jj_2_36(2147483647)) {
      d = decimalDayNamedMonthStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_37(2147483647)) {
      d = monthDecimalDayStrictYear();
{if ("" != null) return d;}
    } else if (jj_2_38(2147483647)) {
      d = strictYearMonthDecimalDay();
{if ("" != null) return d;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      Y-i/........... Yy   
 *      Y-i/i:i........ YyHM 
 *      Y-i/i:i:i...... YyHMS
 *      Y-i/i:i:n...... YyHMS
 *      Y-i/i:n........ YyHM 
 *      Y-id........... Yy   
 *      Y-idi:i........ YyHM 
 *      Y-idi:i:i...... YyHMS
 *      Y-idi:i:n...... YyHMS
 *      Y-idi:n........ YyHM 
 *      Yid............ Yy   
 *      Yidi:i......... YyHM  
 *      Yidi:i:i....... YyHMS 
 *      Yidi:i:n....... YyHMS  
 *      Yidi:n......... YyHM    
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
  final public double strictYearDayOfYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DASH:{
      jj_consume_token(DASH);
      t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case DAYOFYEAR:{
        jj_consume_token(DAYOFYEAR);
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
      jj_consume_token(DAYOFYEAR);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i-i/i:i........ YyHM 
 *      i-i/i:i:i...... YyHMS
 *      i-i/i:i:n...... YyHMS
 *      i-i/i:n........ YyHM 
 *      i-idi:i........ YyHM 
 *      i-idi:i:i...... YyHMS
 *      i-idi:i:n...... YyHMS
 *      i-idi:n........ YyHM 
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double integerMinusDayOfYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
year = Integer.parseInt(t.image);
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SLASH:{
      jj_consume_token(SLASH);
      break;
      }
    case DAYOFYEAR:{
      jj_consume_token(DAYOFYEAR);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    e = integerHourMinuteSecond();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      iid............ Yy
 *      iidi:i......... YyHM
 *      iidi:i:i....... YyHMS
 *      iidi:i:n....... YyHMS
 *      iidi:n......... YyHM 
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
  final public double integerDayOfYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
year = Integer.parseInt(t.image);
    t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
    jj_consume_token(DAYOFYEAR);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i-Y/........... Yy   
 *      i-Y/i:i........ YyHM 
 *      i-Y/i:i:i...... YyHMS
 *      i-Y/i:i:n...... YyHMS
 *      i-Y/i:n........ YyHM 
 *      i-Yd........... Yy   
 *      i-Ydi:i........ YyHM 
 *      i-Ydi:i:i...... YyHMS
 *      i-Ydi:i:n...... YyHMS
 *      i-Ydi:n........ YyHM 
 *      iYd............ yY
 *      iYdi:i......... yYHM
 *      iYdi:i:i....... yYHMS
 *      iYdi:i:n....... yYHMS
 *      iYdi:n......... yYHM
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
  final public double dayOfYearStrictYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DASH:{
      jj_consume_token(DASH);
      year = strictYear();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case DAYOFYEAR:{
        jj_consume_token(DAYOFYEAR);
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case QUOTED_YEAR:
    case YEAR:
    case YEARAD:
    case YEARBC:{
      year = strictYear();
      jj_consume_token(DAYOFYEAR);
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      Yii............ YmD
 *      Yiii........... YmDH
 *      Yiii:i......... YmDHM
 *      Yiii:i:i....... YmDHMS
 *      Yiii:i:n....... YmDHMS
 *      Yiii:n......... YmDHM
 *      Yiiii.......... YmDHM
 *      Yiiiii......... YmDHMS
 *      Yiiiin......... YmDHMS
 *      Yiiin.......... YmDHM
 *      Yiin........... YmDH
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
  final public double spaceDelimitedStrictYearMonthDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    year = strictYear();
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      if (jj_2_39(2147483647)) {
        e = integerHourMinuteSecond();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:
        case UNSIGNED_INTEGER:{
          e = spacedHourMinuteSecond();
          break;
          }
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      Yi............ YD
 *      Yii........... YDH
 *      Yii:i......... YDHM
 *      Yii:i:i....... YDHMS
 *      Yii:i:n....... YDHMS
 *      Yii:n......... YDHM
 *      Yiii.......... YDHM
 *      Yiiii......... YDHMS
 *      Yiiin......... YDHMS
 *      Yiin.......... YDHM
 *      Yin........... YDH
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
  final public double spaceDelimitedStrictYearDayOfYear() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0.0;
   Token t;
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DASH:{
      jj_consume_token(DASH);
      t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case DAYOFYEAR:{
        jj_consume_token(DAYOFYEAR);
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
      jj_consume_token(DAYOFYEAR);
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      if (jj_2_40(2147483647)) {
        e = integerHourMinuteSecond();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:
        case UNSIGNED_INTEGER:{
          e = spacedHourMinuteSecond();
          break;
          }
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i-i-Y.......... mDY    
 *      i-i-Yi:i....... mDYHM  
 *      i-i-Yi:i:i..... mDYHMS 
 *      i-i-Yi:i:n..... mDYHMS 
 *      i-i-Yi:n....... mDYHM  
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double dashedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(DASH);
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i/i/Y.......... mDY     
 *      i/i/Yi:i....... mDYHM  
 *      i/i/Yi:n....... mDYHM
 *      i/i/Yi:i:i..... mDYHMS 
 *      i/i/Yi:i:n..... mDYHMS 
 *      i/i/Y/i:i...... mDYHM 
 *      i/i/Y/i:n...... mDYHM 
 *      i/i/Y/i:i:i.... mDYHM 
 *      i/i/Y/i:i:n.... mDYHM 
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double slashedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:
    case SLASH:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i/i/i.......... mDY    
 *      i/i/ii:i....... mDYHM  
 *      i/i/ii:i:i..... mDYHMS
 *      i/i/ii:i:n..... mDYHMS
 *      i/i/ii:n....... mDYHM
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double slashedMonthDayInteger() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
year=Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNSIGNED_INTEGER:{
      e = integerHourMinuteSecond();
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i:ii-i-Y....... mDYHM  
 *      i:i:ii-i-Y..... mDYHMS 
 *      i:i:ni-i-Y..... mDYHMS 
 *      i:ni-i-Y....... mDYHM  
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingDashedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(DASH);
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i:ii/i/Y....... mDYHM  
 *      i:ni/i/Y....... mDYHM
 *      i:i:ii/i/Y..... mDYHMS 
 *      i:i:ni/i/Y..... mDYHMS 
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingSlashedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i:ii/i/i....... mDYHM  
 *      i:i:ii/i/i..... mDYHMS
 *      i:i:ni/i/i..... mDYHMS
 *      i:ni/i/i....... mDYHM
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingSlashedMonthDayInteger() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(SLASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
year=Integer.parseInt(t.image);
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      iiY............ mDY
 *      iiYi........... mDYH
 *      iiYi:i......... mDYHM
 *      iiYi:i:i....... mDYHMS
 *      iiYi:i:n....... mDYHMS
 *      iiYi:n......... mDYHM
 *      iiYn........... mDYH 
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *  <pre>
 *      Yim............ YDm   
 *      Yimi........... YDmH  
 *      Yimi:i......... YDmHM 
 *      Yimi:i:i....... YDmHMS
 *      Yimi:i:n....... YDmHMS
 *      Yimi:n......... YDmHM 
 *      Yimn........... YDmH  
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedStrictYearDayNamedMonth() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    year = strictYear();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *  <pre>
 *      Ymi............ YmD    
 *      Ymii........... YmDH   
 *      Ymii:i......... YmDHM  
 *      Ymii:i:i....... YmDHMS 
 *      Ymii:i:n....... YmDHMS 
 *      Ymii:n......... YmDHM  
 *      Ymin........... YmDH   
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedStrictYearNamedMonthDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    year = strictYear();
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      iim............ YDm
 *      iimi........... YDmH
 *      iimi:i......... YDmHM
 *      iimi:i:i....... YDmHMS
 *      iimi:i:n....... YDmHMS
 *      iimi:n......... YDmHM
 *      iimii.......... YDmHM
 *      iimiii......... YDmHMS
 *      iimiin......... YDmHMS
 *      iimin.......... YDmHM
 *      iimn........... YDmH
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedIntegerDayNamedMonth() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
year=Integer.parseInt(t.image);
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      if (jj_2_41(2147483647)) {
        e = integerHourMinuteSecond();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:
        case UNSIGNED_INTEGER:{
          e = spacedHourMinuteSecond();
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     imY............ DmY
 *     imYi........... DmYH
 *     imYi:i......... DmYHM
 *     imYi:i:i....... DmYHMS
 *     imYi:i:n....... DmYHMS
 *     imYi:n......... DmYHM
 *     imYn........... DmYH
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedDayNamedMonthStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      iim............ YDm
 *      imi............ YmD
 *      imii........... YmDH
 *      imii:i......... YmDHM
 *      imii:i:i....... YmDHMS
 *      imii:i:n....... YmDHMS
 *      imii:n......... YmDHM
 *      imiii.......... YmDHM
 *      imiiii......... YmDHMS
 *      imiiin......... YmDHMS
 *      imiin.......... YmDHM
 *      imin........... YmDH
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedIntegerNamedMonthDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
year=Integer.parseInt(t.image);
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      if (jj_2_42(2147483647)) {
        e = integerHourMinuteSecond();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:
        case UNSIGNED_INTEGER:{
          e = spacedHourMinuteSecond();
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     miY............ mDY
 *     miYi........... mDYH
 *     miYi:i......... mDYHM
 *     miYi:i:i....... mDYHMS
 *     miYi:i:n....... mDYHMS
 *     miYi:n......... mDYHM
 *     miYn........... mDYH
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedNamedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      e = hourMinuteSecond();
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *  <pre>
 *     mii............ mDY
 *     miii........... mDYH
 *     miii:i......... mDYHM
 *     miii:i:i....... mDYHMS
 *     miii:i:n....... mDYHMS
 *     miii:n......... mDYHM
 *     miiii.......... mDYHM
 *     miiiii......... mDYHMS
 *     miiiin......... mDYHMS
 *     miiin.......... mDYHM
 *     miin........... mDYH
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spaceDelimitedNamedMonthDayInteger() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    t = jj_consume_token(UNSIGNED_INTEGER);
year=Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:
    case UNSIGNED_INTEGER:{
      if (jj_2_43(2147483647)) {
        e = integerHourMinuteSecond();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:
        case UNSIGNED_INTEGER:{
          e = spacedHourMinuteSecond();
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
      }
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     imi:i:iY....... DmHMSY
 *     imi:i:nY....... DmHMSY
 *     imi:iY......... DmHMY
 *     imi:nY......... DmHMY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double dayNamedMonthSplitStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    e = integerHourMinuteSecond();
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *  <pre>
 *     mii:i:iY....... mDHMSY
 *     mii:i:nY....... mDHMSY
 *     mii:iY......... mDHMY
 *     mii:nY......... mDHMY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double namedMonthDaySplitStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    e = integerHourMinuteSecond();
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     i:i:iimY....... HMSDmY
 *     i:i:nimY....... HMSDmY
 *     i:iimY......... HMDmY
 *     i:nimY......... HMDmY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingDayNamedMonthStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     i:i:imiY....... HMSmDY
 *     i:i:nmiY....... HMSmDY
 *     i:imiY......... HMmDY
 *     i:nmiY......... HMmDY
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingNamedMonthDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     i:i:iYmi....... HMSYmD
 *     i:i:nYmi....... HMSYmD
 *     i:iYmi......... HMYmD
 *     i:nYmi......... HMYmD
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingStrictYearNamedMonthDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    year = strictYear();
    month = namedMonth();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     i:i:iYim....... HMSYDm
 *     i:i:nYim....... HMSYDm
 *     i:iYim......... HMYDm
 *     i:nYim......... HMYDm
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingStrictYearDayNamedMonth() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    e = integerHourMinuteSecond();
    year = strictYear();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i:i:ii-id...... HMSYy
 *      i:i:ni-id...... HMSYy
 *      i:i:ii-i/...... HMSYy
 *      i:i:ni-i/...... HMSYy
 *      i:ii-id........ HMYy
 *      i:ni-id........ HMYy
 *      i:ii-i/........ HMYy
 *      i:ni-i/........ HMYy
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingStrictYearMinusDayOfYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    e = integerHourMinuteSecond();
    year = strictYear();
    jj_consume_token(DASH);
    t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DAYOFYEAR:
    case SLASH:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case DAYOFYEAR:{
        jj_consume_token(DAYOFYEAR);
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *      i:i:ii-id...... HMSYy
 *      i:i:ni-id...... HMSYy
 *      i:i:ii-i/...... HMSYy
 *      i:i:ni-i/...... HMSYy
 *      i:ii-id........ HMYy
 *      i:ni-id........ HMYy
 *      i:ii-i/........ HMYy
 *      i:ni-i/........ HMYy
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double trailingDayOfYearMinusStrictYearDelimiter() throws ParseException {int year;
   int dayOfYear;
   double d;
   double e=0;
   Token t;
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
dayOfYear = Integer.parseInt(t.image);
    jj_consume_token(DASH);
    year = strictYear();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DAYOFYEAR:
    case SLASH:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case DAYOFYEAR:{
        jj_consume_token(DAYOFYEAR);
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, dayOfYear);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     Yi:i:iim....... YHMSDm
 *     Yi:i:nim....... YHMSDm
 *     Yi:iim......... YHMDm
 *     Yi:nim......... YHMDm
 *
 *   @return  seconds past the J2000 reference epoch on a formal
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double leadingStrictYearTrailingDayNamedMonth() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e=0.0;
   Token t;
    year = strictYear();
    e = integerHourMinuteSecond();
    t = jj_consume_token(UNSIGNED_INTEGER);
day=Integer.parseInt(t.image);
    month = namedMonth();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.
       */
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     Ymn............ YmD
 *     imn............ YmD
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double yearNamedMonthDecimalDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    year = looseYear();
    month = namedMonth();
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     Ynm............ YDm
 *     inm............ YDm
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double yearDecimalDayNamedMonth() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    year = looseYear();
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    month = namedMonth();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     mnY............ mDY
 *     mni............ mDY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double namedMonthDecimalDayYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    month = namedMonth();
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    year = looseYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     nmY............ DmY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double decimalDayNamedMonthStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    month = namedMonth();
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     inY............ mDY
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double monthDecimalDayStrictYear() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    year = strictYear();
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  This non-terminal parses strings that start with the form:
 *     Yin............ YmD
 *
 *   @return  seconds past the J2000 reference epoch on a formal 
 *            86400 seconds per day calendar.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double strictYearMonthDecimalDay() throws ParseException {int year;
   int month;
   int day;
   double d;
   double e;
   Token t;
    year = strictYear();
    t = jj_consume_token(UNSIGNED_INTEGER);
month=Integer.parseInt(t.image);
    t = jj_consume_token(NUMBER);
e=Double.parseDouble(t.image);
    jj_consume_token(0);
/*
       *  First correct the year for any era specification noted by the
       *  token manager.  Then adjust any two digit years into the proper
       *  century.
       */
      year = correctYearForEra(year);
      year = processTwoDigitYears(year);

      /*
       *  Now apply Muller-Wimberly to convert the year and day of year
       *  into seconds past J2000.  In order to do this we need to strip
       *  the integral part of the decimal day, e.  We can simply use the
       *  floor function, since e is guarenteed by the token manager to
       *  be a non-negative decimal number.
       */
      day = (int)Math.floor(e);
      e = (e - Math.floor(e))*SECONDS_PER_DAY;
      d = mullerWimberly(year, month, day);

      {if ("" != null) return d+e;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse a token that "might" be a year, but should be interpretted
 *  as one.
 *
 *  Tokens that "might" be years come in two flavors:
 *  <pre>
 *     <UNSIGNED_INTEGER> - this sequence of digits should be interpretted
 *                          as a year.
 *     strictYear() - anything acceptable to the non-terminal strictYear()
 *                    can obviously be interpretted loosely as a year!
 *  </pre>
 *
 *  @return  a integer containing the raw, unprocessed year.  This will 
 *           not be corrected for any era specification or two digit year
 *           processing.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public int looseYear() throws ParseException {Token t;
   int y;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case QUOTED_YEAR:
    case YEAR:
    case YEARAD:
    case YEARBC:{
      y = strictYear();
{if ("" != null) return y;}
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
{if ("" != null) return Integer.parseInt(t.image);}
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/*
 *  Parse a token that must be a year.
 *
 *  Tokens that must be years come in three flavors:
 *  <pre>
 *     <YEAR> - any four digit or greater unsigned integer
 *     <YEARAD> - any sequence of digits followed by the era token <AD>
 *     <YEARBC> - any sequence of digits followed by the era token <BC>
 *     <QUOTED_YEAR> - any sequence of less than 3 digits preceded by "'"
 *  </pre>
 *
 *  @return  a integer containing the year, as specified by the token.
 *           Note: this year is NOT processed for two digit years, nor
 *           is it corrected for the specified era.  This is deferred
 *           until other routines.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public int strictYear() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case YEAR:{
      t = jj_consume_token(YEAR);
      break;
      }
    case YEARAD:{
      t = jj_consume_token(YEARAD);
      break;
      }
    case YEARBC:{
      t = jj_consume_token(YEARBC);
      break;
      }
    case QUOTED_YEAR:{
      t = jj_consume_token(QUOTED_YEAR);
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse a named month into its integer equivalent.
 *  
 *  @return  the integer number, starting with 1, corresponding to
 *           the named month.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public int namedMonth() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case JAN:{
      jj_consume_token(JAN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
{if ("" != null) return 1;}
      break;
      }
    case FEB:{
      jj_consume_token(FEB);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        ;
      }
{if ("" != null) return 2;}
      break;
      }
    case MAR:{
      jj_consume_token(MAR);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        ;
      }
{if ("" != null) return 3;}
      break;
      }
    case APR:{
      jj_consume_token(APR);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
{if ("" != null) return 4;}
      break;
      }
    case MAY:{
      jj_consume_token(MAY);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        ;
      }
{if ("" != null) return 5;}
      break;
      }
    case JUN:{
      jj_consume_token(JUN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        ;
      }
{if ("" != null) return 6;}
      break;
      }
    case JUL:{
      jj_consume_token(JUL);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[51] = jj_gen;
        ;
      }
{if ("" != null) return 7;}
      break;
      }
    case AUG:{
      jj_consume_token(AUG);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        ;
      }
{if ("" != null) return 8;}
      break;
      }
    case SEP:{
      jj_consume_token(SEP);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        ;
      }
{if ("" != null) return 9;}
      break;
      }
    case OCT:{
      jj_consume_token(OCT);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        ;
      }
{if ("" != null) return 10;}
      break;
      }
    case NOV:{
      jj_consume_token(NOV);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        ;
      }
{if ("" != null) return 11;}
      break;
      }
    case DEC:{
      jj_consume_token(DEC);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PERIOD:{
        jj_consume_token(PERIOD);
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        ;
      }
{if ("" != null) return 12;}
      break;
      }
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

/*
 *  Parse the hour, minute, second specification where the hour followed
 *  by a colon is required.
 *
 *  This non-terminal parses a standard, colon delimited, hours, minutes,
 *  and second time specification.  This particular non-terminal requires
 *  that the hour followed by a colon followed by a minute specification 
 *  be present, and that the hour is an integer.
 *
 *  A terminal 'Z' character is ignored if it exists.
 *
 *  @return  the number of seconds elapsed from 00:00:00.000 as specified
 *           by the tokens in the stream connected to the parser.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double integerHourMinuteSecond() throws ParseException {double d=0.0;
        String h = null;
        String m = null;
        String s = null;
        Token t,u;
    t = jj_consume_token(UNSIGNED_INTEGER);
h = t.image;
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:{
      t = jj_consume_token(NUMBER);
m = t.image;
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
m = t.image;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COLON:{
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:{
          t = jj_consume_token(NUMBER);
s = t.image;
          break;
          }
        case UNSIGNED_INTEGER:{
          t = jj_consume_token(UNSIGNED_INTEGER);
s = t.image;
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Z:{
        jj_consume_token(Z);
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      break;
      }
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if ( h != null ) {
          h = correctHourForAMPM(h);
         d += 3600.0 * Double.parseDouble(h);
      }
      if ( m != null ) {
         d += 60.0 * Double.parseDouble(m);
      }
      if ( s != null ) {
         d += Double.parseDouble(s);
      }

      {if ("" != null) return d;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse a non-colon delimited hour, minute, second specification.
 *
 *  This non-terminal parses the a standard hour, minutes, and second time
 *  specification.  It allows for the final field of the stream to contain
 *  a floating point number, rather than an integral amount.
 *
 *  @return  the number of seconds ellapsed from 00:00:00.000 as specified
 *           by the tokens in the stream connected to the parser.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double spacedHourMinuteSecond() throws ParseException {double d=0.0;
   String h=null;
   String m=null;
   String s=null;
   Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:{
      t = jj_consume_token(NUMBER);
h = t.image;
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
h = t.image;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUMBER:
      case UNSIGNED_INTEGER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:{
          t = jj_consume_token(NUMBER);
m = t.image;
          break;
          }
        case UNSIGNED_INTEGER:{
          t = jj_consume_token(UNSIGNED_INTEGER);
m = t.image;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case NUMBER:
          case UNSIGNED_INTEGER:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NUMBER:{
              t = jj_consume_token(NUMBER);
s = t.image;
              break;
              }
            case UNSIGNED_INTEGER:{
              t = jj_consume_token(UNSIGNED_INTEGER);
s = t.image;
              break;
              }
            default:
              jj_la1[62] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[63] = jj_gen;
            ;
          }
          break;
          }
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      break;
      }
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if ( h != null ) {
          h = correctHourForAMPM(h);
         d += 3600.0 * Double.parseDouble(h);
      }
      if ( m != null ) {
         d += 60.0 * Double.parseDouble(m);
      }
      if ( s != null ) {
         d += Double.parseDouble(s);
      }

      {if ("" != null) return d;}
    throw new Error("Missing return statement in function");
}

/*
 *  Parse the hour, minute, second specification.
 *
 *  This non-terminal parses the a standard, colon delimited, hours, minutes, 
 *  and second time specification.  It allows for the final field of the 
 *  stream to contain a floating point number, rather than an integral amount.
 *
 *  A terminal 'Z' character is ignored if it exists.
 *
 *  @return  the number of seconds elapsed from 00:00:00.000 as specified
 *           by the tokens in the stream connected to the parser.
 */
/**
 *  Supporting non-terminal, <b>do not call directly</b>.
 */
  final public double hourMinuteSecond() throws ParseException {double d=0.0;
   String h = null;
   String m = null;
   String s = null;
   Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:{
      t = jj_consume_token(NUMBER);
h = t.image;
      break;
      }
    case UNSIGNED_INTEGER:{
      t = jj_consume_token(UNSIGNED_INTEGER);
h = t.image;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COLON:{
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NUMBER:{
          t = jj_consume_token(NUMBER);
m = t.image;
          break;
          }
        case UNSIGNED_INTEGER:{
          t = jj_consume_token(UNSIGNED_INTEGER);
m = t.image;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case COLON:{
            jj_consume_token(COLON);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case NUMBER:{
              t = jj_consume_token(NUMBER);
s = t.image;
              break;
              }
            case UNSIGNED_INTEGER:{
              t = jj_consume_token(UNSIGNED_INTEGER);
s = t.image;
              break;
              }
            default:
              jj_la1[67] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[68] = jj_gen;
            ;
          }
          break;
          }
        default:
          jj_la1[69] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Z:{
        jj_consume_token(Z);
        break;
        }
      default:
        jj_la1[71] = jj_gen;
        ;
      }
      break;
      }
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if ( h != null ) {
          h = correctHourForAMPM(h);
         d += 3600.0 * Double.parseDouble(h);
      }
      if ( m != null ) {
         d += 60.0 * Double.parseDouble(m);
      }
      if ( s != null ) {
         d += Double.parseDouble(s);
      }

      {if ("" != null) return d;}
    throw new Error("Missing return statement in function");
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_24()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_25()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_26()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_27()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_28()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_29()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_30()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_31()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_32()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_33()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_34()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_35()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_36()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_37()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_38()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_39()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_40()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_41()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_42()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_43()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_3R_isoTime_760_4_2()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_isoTime_760_6_42()) {
    jj_scanpos = xsp;
    if (jj_3R_isoTime_762_6_43()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_isoTime_763_6_44()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_strictYearMonthDecimalDay_2675_4_38()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(NUMBER)) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_trailingStrictYearMinusDayOfYearDelimiter_2288_6_69()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  private boolean jj_3R_trailingStrictYearMinusDayOfYearDelimiter_2285_4_30()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_trailingStrictYearMinusDayOfYearDelimiter_2288_6_69()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_trailingSlashedMonthDayInteger_1516_4_15()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayStrictYear_1887_9_67()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayStrictYear_1884_4_22()
 {
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedNamedMonthDayStrictYear_1887_9_67()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_dayOfYearStrictYearDelimiter_1106_6_52()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_dayOfYearStrictYearDelimiter_1105_6_51()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(DAYOFYEAR)) return true;
    return false;
  }

  private boolean jj_3R_dayOfYearStrictYearDelimiter_1104_6_50()
 {
    if (jj_scan_token(DASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  private boolean jj_3R_dayOfYearStrictYearDelimiter_1103_4_7()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_dayOfYearStrictYearDelimiter_1104_6_50()) {
    jj_scanpos = xsp;
    if (jj_3R_dayOfYearStrictYearDelimiter_1105_6_51()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_dayOfYearStrictYearDelimiter_1106_6_52()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_monthDecimalDayStrictYear_2627_4_37()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(NUMBER)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_trailingStrictYearDayNamedMonth_2233_4_29()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_42()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_trailingSlashedMonthDayStrictYear_1463_4_14()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerNamedMonthDay_1836_9_97()
 {
    if (jj_3R_spacedHourMinuteSecond_2861_4_105()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerNamedMonthDay_1834_9_66()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedIntegerNamedMonthDay_1834_9_96()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedIntegerNamedMonthDay_1836_9_97()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerNamedMonthDay_1834_9_96()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerNamedMonthDay_1831_4_21()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedIntegerNamedMonthDay_1834_9_66()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_integerDayOfYearDelimiter_1052_5_49()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_integerDayOfYearDelimiter_1049_4_6()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DAYOFYEAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_integerDayOfYearDelimiter_1052_5_49()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_decimalDayNamedMonthStrictYear_2579_4_36()
 {
    if (jj_scan_token(NUMBER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_julianDate_656_9_75()
 {
    if (jj_scan_token(DASH)) return true;
    return false;
  }

  private boolean jj_3R_julianDate_656_7_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_julianDate_656_9_75()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    }
    if (jj_scan_token(JD)) return true;
    return false;
  }

  private boolean jj_3R_julianDate_650_9_74()
 {
    if (jj_scan_token(DASH)) return true;
    return false;
  }

  private boolean jj_3R_trailingStrictYearNamedMonthDay_2184_4_28()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_julianDate_649_6_40()
 {
    if (jj_scan_token(JD)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_julianDate_650_9_74()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(1)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_julianDate_649_4_1()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_julianDate_649_6_40()) {
    jj_scanpos = xsp;
    if (jj_3R_julianDate_656_7_41()) return true;
    }
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_trailingDashedMonthDayStrictYear_1410_4_13()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2909_36_104()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_hourMinuteSecond_2910_9_108()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2914_26_118()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2913_26_117()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedDayNamedMonthStrictYear_1778_9_65()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2913_16_114()
 {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_hourMinuteSecond_2913_26_117()) {
    jj_scanpos = xsp;
    if (jj_3R_hourMinuteSecond_2914_26_118()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedDayNamedMonthStrictYear_1775_4_20()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedDayNamedMonthStrictYear_1778_9_65()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2912_13_112()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_hourMinuteSecond_2913_16_114()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_integerMinusDayOfYearDelimiter_1006_4_5()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2911_13_111()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2910_9_108()
 {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_hourMinuteSecond_2911_13_111()) {
    jj_scanpos = xsp;
    if (jj_3R_hourMinuteSecond_2912_13_112()) return true;
    }
    return false;
  }

  private boolean jj_3R_namedMonthDecimalDayYear_2531_4_35()
 {
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(NUMBER)) return true;
    if (jj_3R_looseYear_2728_6_71()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2909_6_103()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_hourMinuteSecond_2909_4_77()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_hourMinuteSecond_2909_6_103()) {
    jj_scanpos = xsp;
    if (jj_3R_hourMinuteSecond_2909_36_104()) return true;
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_isoTime_760_4_2()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_julianDate_649_4_1()) return true;
    return false;
  }

  private boolean jj_3R_trailingNamedMonthDayStrictYear_2135_4_27()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_slashedMonthDayInteger_1361_8_59()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2861_36_110()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spacedHourMinuteSecond_2862_10_113()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_strictYearDayOfYearDelimiter_955_24_46()
 {
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  private boolean jj_3R_slashedMonthDayInteger_1358_4_12()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_slashedMonthDayInteger_1361_8_59()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_41()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerDayNamedMonth_1727_9_95()
 {
    if (jj_3R_spacedHourMinuteSecond_2861_4_105()) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2865_18_121()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerDayNamedMonth_1725_9_64()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedIntegerDayNamedMonth_1725_9_94()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedIntegerDayNamedMonth_1727_9_95()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerDayNamedMonth_1725_9_94()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2864_18_120()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_strictYearDayOfYearDelimiter_960_6_48()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2864_16_119()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spacedHourMinuteSecond_2864_18_120()) {
    jj_scanpos = xsp;
    if (jj_3R_spacedHourMinuteSecond_2865_18_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_strictYearDayOfYearDelimiter_958_4_47()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DAYOFYEAR)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedIntegerDayNamedMonth_1722_4_19()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedIntegerDayNamedMonth_1725_9_64()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_strictYearDayOfYearDelimiter_955_4_4()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_strictYearDayOfYearDelimiter_955_24_46()) {
    jj_scanpos = xsp;
    if (jj_3R_strictYearDayOfYearDelimiter_958_4_47()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_strictYearDayOfYearDelimiter_960_6_48()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2863_10_116()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spacedHourMinuteSecond_2864_16_119()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2862_10_115()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2862_10_113()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spacedHourMinuteSecond_2862_10_115()) {
    jj_scanpos = xsp;
    if (jj_3R_spacedHourMinuteSecond_2863_10_116()) return true;
    }
    return false;
  }

  private boolean jj_3R_yearDecimalDayNamedMonth_2482_4_34()
 {
    if (jj_3R_looseYear_2728_6_71()) return true;
    if (jj_scan_token(NUMBER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2861_6_109()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3R_spacedHourMinuteSecond_2861_4_105()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spacedHourMinuteSecond_2861_6_109()) {
    jj_scanpos = xsp;
    if (jj_3R_spacedHourMinuteSecond_2861_36_110()) return true;
    }
    return false;
  }

  private boolean jj_3R_trailingDayNamedMonthStrictYear_2087_4_26()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_slashedMonthDayStrictYear_1313_8_58()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) jj_scanpos = xsp;
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3_38()
 {
    if (jj_3R_strictYearMonthDecimalDay_2675_4_38()) return true;
    return false;
  }

  private boolean jj_3_37()
 {
    if (jj_3R_monthDecimalDayStrictYear_2627_4_37()) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2818_28_107()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  private boolean jj_3_36()
 {
    if (jj_3R_decimalDayNamedMonthStrictYear_2579_4_36()) return true;
    return false;
  }

  private boolean jj_3R_slashedMonthDayStrictYear_1310_4_11()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(SLASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_slashedMonthDayStrictYear_1313_8_58()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2817_28_106()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3_35()
 {
    if (jj_3R_namedMonthDecimalDayYear_2531_4_35()) return true;
    return false;
  }

  private boolean jj_3_34()
 {
    if (jj_3R_yearDecimalDayNamedMonth_2482_4_34()) return true;
    return false;
  }

  private boolean jj_3_33()
 {
    if (jj_3R_yearNamedMonthDecimalDay_2433_4_33()) return true;
    return false;
  }

  private boolean jj_3_32()
 {
    if (jj_3R_leadingStrictYearTrailingDayNamedMonth_2385_4_32()) return true;
    return false;
  }

  private boolean jj_3_31()
 {
    if (jj_3R_trailingDayOfYearMinusStrictYearDelimiter_2337_4_31()) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2817_17_102()
 {
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_integerHourMinuteSecond_2817_28_106()) {
    jj_scanpos = xsp;
    if (jj_3R_integerHourMinuteSecond_2818_28_107()) return true;
    }
    return false;
  }

  private boolean jj_3_30()
 {
    if (jj_3R_trailingStrictYearMinusDayOfYearDelimiter_2285_4_30()) return true;
    return false;
  }

  private boolean jj_3_29()
 {
    if (jj_3R_trailingStrictYearDayNamedMonth_2233_4_29()) return true;
    return false;
  }

  private boolean jj_3_28()
 {
    if (jj_3R_trailingStrictYearNamedMonthDay_2184_4_28()) return true;
    return false;
  }

  private boolean jj_3_27()
 {
    if (jj_3R_trailingNamedMonthDayStrictYear_2135_4_27()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearNamedMonthDay_1671_8_63()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2816_12_73()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_integerHourMinuteSecond_2817_17_102()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(12)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_26()
 {
    if (jj_3R_trailingDayNamedMonthStrictYear_2087_4_26()) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2815_11_72()
 {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_3R_namedMonthDaySplitStrictYear_2039_4_25()) return true;
    return false;
  }

  private boolean jj_3R_integerHourMinuteSecond_2814_9_39()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_integerHourMinuteSecond_2815_11_72()) {
    jj_scanpos = xsp;
    if (jj_3R_integerHourMinuteSecond_2816_12_73()) return true;
    }
    return false;
  }

  private boolean jj_3_24()
 {
    if (jj_3R_dayNamedMonthSplitStrictYear_1990_4_24()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearNamedMonthDay_1668_4_18()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearNamedMonthDay_1671_8_63()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_3R_spaceDelimitedNamedMonthDayInteger_1940_4_23()) return true;
    return false;
  }

  private boolean jj_3R_yearNamedMonthDecimalDay_2433_4_33()
 {
    if (jj_3R_looseYear_2728_6_71()) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(NUMBER)) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_3R_spaceDelimitedNamedMonthDayStrictYear_1884_4_22()) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_3R_spaceDelimitedIntegerNamedMonthDay_1831_4_21()) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_3R_spaceDelimitedDayNamedMonthStrictYear_1775_4_20()) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_3R_spaceDelimitedIntegerDayNamedMonth_1722_4_19()) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_spaceDelimitedStrictYearNamedMonthDay_1668_4_18()) return true;
    return false;
  }

  private boolean jj_3R_namedMonthDaySplitStrictYear_2039_4_25()
 {
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_3R_spaceDelimitedStrictYearDayNamedMonth_1617_4_17()) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_3R_spaceDelimitedMonthDayStrictYear_1566_4_16()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_3R_trailingSlashedMonthDayInteger_1516_4_15()) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_3R_trailingSlashedMonthDayStrictYear_1463_4_14()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_trailingDashedMonthDayStrictYear_1410_4_13()) return true;
    return false;
  }

  private boolean jj_3R_dashedMonthDayStrictYear_1260_8_57()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_3R_slashedMonthDayInteger_1358_4_12()) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_slashedMonthDayStrictYear_1310_4_11()) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_3R_dashedMonthDayStrictYear_1257_4_10()) return true;
    return false;
  }

  private boolean jj_3R_dashedMonthDayStrictYear_1257_4_10()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_dashedMonthDayStrictYear_1260_8_57()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1206_4_9()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2785_6_93()
 {
    if (jj_scan_token(DEC)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_spaceDelimitedStrictYearMonthDay_1154_4_8()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2784_6_92()
 {
    if (jj_scan_token(NOV)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2783_6_91()
 {
    if (jj_scan_token(OCT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_dayOfYearStrictYearDelimiter_1103_4_7()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2782_6_90()
 {
    if (jj_scan_token(SEP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2781_6_89()
 {
    if (jj_scan_token(AUG)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_integerDayOfYearDelimiter_1049_4_6()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2780_6_88()
 {
    if (jj_scan_token(JUL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2779_6_87()
 {
    if (jj_scan_token(JUN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_integerMinusDayOfYearDelimiter_1006_4_5()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2778_6_86()
 {
    if (jj_scan_token(MAY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2777_6_85()
 {
    if (jj_scan_token(APR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_strictYearDayOfYearDelimiter_955_4_4()) return true;
    return false;
  }

  private boolean jj_3R_namedMonth_2776_6_84()
 {
    if (jj_scan_token(MAR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2775_6_83()
 {
    if (jj_scan_token(FEB)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_namedMonth_2774_6_61()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_namedMonth_2774_6_82()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2775_6_83()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2776_6_84()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2777_6_85()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2778_6_86()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2779_6_87()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2780_6_88()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2781_6_89()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2782_6_90()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2783_6_91()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2784_6_92()) {
    jj_scanpos = xsp;
    if (jj_3R_namedMonth_2785_6_93()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_namedMonth_2774_6_82()
 {
    if (jj_scan_token(JAN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayNamedMonth_1620_8_62()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_leadingStrictYearTrailingDayNamedMonth_2385_4_32()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayNamedMonth_1617_4_17()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearDayNamedMonth_1620_8_62()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1206_24_54()
 {
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  private boolean jj_3R_dayNamedMonthSplitStrictYear_1990_4_24()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_strictYear_2756_4_45()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(3)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(2)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_40()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1213_14_81()
 {
    if (jj_3R_spacedHourMinuteSecond_2861_4_105()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1211_6_56()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1211_6_80()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1213_14_81()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1211_6_80()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_isoYearDay_828_4_76()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) return true;
    }
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(ISOT)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1209_4_55()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DAYOFYEAR)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearDayOfYear_1206_4_9()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1206_24_54()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1209_4_55()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearDayOfYear_1211_6_56()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_looseYear_2729_6_101()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_looseYear_2728_6_71()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_looseYear_2728_6_100()) {
    jj_scanpos = xsp;
    if (jj_3R_looseYear_2729_6_101()) return true;
    }
    return false;
  }

  private boolean jj_3R_looseYear_2728_6_100()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    return false;
  }

  private boolean jj_3R_trailingDayOfYearMinusStrictYearDelimiter_2341_6_70()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  private boolean jj_3_43()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedMonthDayStrictYear_1569_8_60()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_trailingDayOfYearMinusStrictYearDelimiter_2337_4_31()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_trailingDayOfYearMinusStrictYearDelimiter_2341_6_70()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayInteger_1945_9_99()
 {
    if (jj_3R_spacedHourMinuteSecond_2861_4_105()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedMonthDayStrictYear_1566_4_16()
 {
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_3R_strictYear_2756_4_45()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedMonthDayStrictYear_1569_8_60()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_isoYearMonthDay_799_4_3()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(3)) return true;
    }
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(DASH)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(ISOT)) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayInteger_1943_9_68()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedNamedMonthDayInteger_1943_9_98()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedNamedMonthDayInteger_1945_9_99()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayInteger_1943_9_98()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedNamedMonthDayInteger_1940_4_23()
 {
    if (jj_3R_namedMonth_2774_6_61()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedNamedMonthDayInteger_1943_9_68()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_39()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearMonthDay_1159_9_79()
 {
    if (jj_3R_spacedHourMinuteSecond_2861_4_105()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearMonthDay_1157_9_53()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearMonthDay_1157_9_78()) {
    jj_scanpos = xsp;
    if (jj_3R_spaceDelimitedStrictYearMonthDay_1159_9_79()) return true;
    }
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearMonthDay_1157_9_78()
 {
    if (jj_3R_integerHourMinuteSecond_2814_9_39()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_isoYearMonthDay_799_4_3()) return true;
    return false;
  }

  private boolean jj_3R_spaceDelimitedStrictYearMonthDay_1154_4_8()
 {
    if (jj_3R_strictYear_2756_4_45()) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    if (jj_scan_token(UNSIGNED_INTEGER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_spaceDelimitedStrictYearMonthDay_1157_9_53()) jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3R_isoTime_763_6_44()
 {
    if (jj_3R_hourMinuteSecond_2909_4_77()) return true;
    return false;
  }

  private boolean jj_3R_isoTime_762_6_43()
 {
    if (jj_3R_isoYearDay_828_4_76()) return true;
    return false;
  }

  private boolean jj_3R_isoTime_760_6_42()
 {
    if (jj_3R_isoYearMonthDay_799_4_3()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public TParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[73];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0xff00001e,0x0,0x1a,0x0,0x1a,0x41a,0x18,0x12,0x18,0x18,0x0,0x10,0x10,0x0,0x10,0x0,0xc,0x10,0x12,0x12,0x0,0x10,0x12,0x12,0x10,0x0,0x10,0x10,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x0,0x0,0x0,0x0,0x1c,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff000000,0x12,0x0,0x1000,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x0,0x12,0x0,0x1000,0x12,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x3f,0x40,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x600,0x40,0x0,0x600,0x0,0x600,0x70,0x0,0x0,0x0,0x600,0x40,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x600,0x600,0x600,0x30,0x30,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,0xf,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x0,};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[43];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public TParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new TParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public TParser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new TParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new TParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TParser(TParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 73; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[44];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 73; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 44; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 43; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			   case 23: jj_3_24(); break;
			   case 24: jj_3_25(); break;
			   case 25: jj_3_26(); break;
			   case 26: jj_3_27(); break;
			   case 27: jj_3_28(); break;
			   case 28: jj_3_29(); break;
			   case 29: jj_3_30(); break;
			   case 30: jj_3_31(); break;
			   case 31: jj_3_32(); break;
			   case 32: jj_3_33(); break;
			   case 33: jj_3_34(); break;
			   case 34: jj_3_35(); break;
			   case 35: jj_3_36(); break;
			   case 36: jj_3_37(); break;
			   case 37: jj_3_38(); break;
			   case 38: jj_3_39(); break;
			   case 39: jj_3_40(); break;
			   case 40: jj_3_41(); break;
			   case 41: jj_3_42(); break;
			   case 42: jj_3_43(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
